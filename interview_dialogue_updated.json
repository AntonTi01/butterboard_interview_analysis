{
    "dialogue": [
        {
            "speaker": "candidate",
            "timestamp_start": "00:00:54,280",
            "timestamp_end": "00:01:10,260",
            "text": "Три-четыре года был WebMoney опыт. Касаемо проектов, самые интересные это были C2C, то есть у нас была внутренняя валюта в рамках компании, и её нужно было переводить, там, к примеру, в доллары, в рубли, то есть некоторая биржевая, так сказать,"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:01:10,300",
            "timestamp_end": "00:01:20,680",
            "text": "Некоторые биржи. Вот. Этот проект у нас был на Monolith. В основном из стека у нас был ASP.NET Core. Последняя версия — это был на тот момент.NET 6-й."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:01:20,920",
            "timestamp_end": "00:01:31,580",
            "text": "Потом мы его тоже переписывали уже на микросервис и переносили. Был опыт с EF-Core, с Dapper. По базам данных был Postgres, SQL-сервер, Docker, то есть все вот эти новомодные штуки."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:01:31,680",
            "timestamp_end": "00:01:38,560",
            "text": "Что касается самой команды, у нас она состояла из 10 до 15 человек примерно в этом интервале."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:01:38,560",
            "timestamp_end": "00:01:44,000",
            "text": "Были в основном по большей части бэкэнд-разработчики на.NET и Java."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:01:44,000",
            "timestamp_end": "00:02:01,530",
            "text": "Был один QI, был архитектор и был Team Lead. Вот. Второй проект — это был СБП, то есть система быстрых платежей. Нужно было как раз, чтобы в нашей системе были переводы по системе СБП. Вот. Этот проект уже был на микросервисах, сразу написан."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:02:01,530",
            "timestamp_end": "00:02:05,220",
            "text": "Поэтому тоже был опыт с монолитом и с микросервисами."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:03:10,300",
            "timestamp_end": "00:03:21,600",
            "text": "Каких кейсов? Ну, это оптимизация у меня была с индексами работа, с джойнами, хронимки переписывал на EF Core, потом с ними тоже у меня был опыт. А что ещё?"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:04:45,650",
            "timestamp_end": "00:04:49,360",
            "text": "Так же было использование уровня Read Committed, ну, там"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:05:30,290",
            "timestamp_end": "00:05:38,580",
            "text": "По каким столбцам у нас будет идти очень активный поиск? Соответственно, самое такое первое решение, которое приходит в голову, это навесить индексы."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:05:38,580",
            "timestamp_end": "00:05:42,490",
            "text": "А второе, когда уже условно таблица сформирована,"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:05:42,490",
            "timestamp_end": "00:05:54,420",
            "text": "Обычно приходит, условно, задачка, там, что запросы выполняются долго, надо посмотреть, вот. И ты идешь, там, смотреть либо план выполнения запросов, и параллельно раскручиваешь систему, есть ли индексы."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:06:44,520",
            "timestamp_end": "00:06:46,960",
            "text": "А какие вообще минусы у индексов?"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:07:08,110",
            "timestamp_end": "00:07:14,540",
            "text": "Вторая проблема — это когда у нас очень часто есть запросы на insert, update, delete, то при"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:07:14,620",
            "timestamp_end": "00:07:32,400",
            "text": "Вот в этих операциях нам нужно, собственно, перестраивать индекс. Нужно, чтобы полностью его перестроить, и чтобы он построился на новых данных. Ну и третье, еще могу сказать, это, условно, когда у нас табличка маленькая, индексы не всегда могут вообще играть роль. Условно, у нас..."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:07:52,860",
            "timestamp_end": "00:08:11,180",
            "text": "У тебя есть приложение, в которое большой трафик, много запросов летит на вставку и на чтение. Вот у тебя табличка из какой-то колонки, да, на вставку в эту колонку и на чтение этой колонки. У тебя задача, вот, поменять"
        },
        {
            "speaker": "interviewer",
            "timestamp_start": "00:08:11,180",
            "timestamp_end": "00:08:20,380",
            "text": "в этой колонке тип например там со строки на число ну допустим на или наоборот вот расскажи поэтапно как бы ты"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:08:29,920",
            "timestamp_end": "00:08:46,090",
            "text": "Угу. Ну, если, условно, у нас в моменте это надо сделать, то я бы к этой таблице ничего не применял бы, никаких изменений, потому что вдруг, если что-то там, условно, ну, сбой какой-то произойдёт, то могут пострадать данные. А я бы просто создал, условно, аналог этой же таблицы."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:09:08,640",
            "timestamp_end": "00:09:12,720",
            "text": "Ну, я бы по-любому начал бы создавать просто новую таблицу."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:10:11,480",
            "timestamp_end": "00:10:13,080",
            "text": "Ну, то есть."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:11:11,260",
            "timestamp_end": "00:11:14,920",
            "text": "Чтобы разъяснить. То есть, сначала мы добавляем табличку, начинаем"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:11:15,020",
            "timestamp_end": "00:11:32,910",
            "text": "Добавляем новую колонку, начинаем писать. Две колонки сразу же. Следующий у тебя этап — это перенести данные. То есть, тебе надо данные из… когда у тебя уже все реплики, там, мультиреплики сработали, да, у тебя все реплики уже начали писать в новую колонку, ты переносишь данные."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:11:32,910",
            "timestamp_end": "00:11:36,040",
            "text": "После этого ты делаешь чтение из новой?"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:11:36,440",
            "timestamp_end": "00:11:37,800",
            "text": "Колонки."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:11:39,320",
            "timestamp_end": "00:11:43,300",
            "text": "А потом, например, старую можно удалить. Либо потом можно"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:11:44,000",
            "timestamp_end": "00:11:50,080",
            "text": "Старую, ну, старую можно удалить, и потом сделать то же самое, короче, для…"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:12:11,080",
            "timestamp_end": "00:12:21,280",
            "text": "«енум», да, в «Пасгаре», потому что «енум» — такая же тема. Там просто так «енум» не удалить. Ну, значение «енума» из типа «енум»."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:12:23,100",
            "timestamp_end": "00:12:34,980",
            "text": "Так, вопросики, вопросики, вопросики. Да, что-то было, сейчас вспомню, что-то я пока рассказывал, как забыл."
        },
        {
            "speaker": "interviewer",
            "timestamp_start": "00:12:36,960",
            "timestamp_end": "00:12:41,220",
            "text": "Ты можешь объяснить, когда вообще нужно использовать GSON, например?"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:13:00,180",
            "timestamp_end": "00:13:02,770",
            "text": "И там нужно было… Ну, допустим,"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:13:02,770",
            "timestamp_end": "00:13:19,480",
            "text": "Не знаю, «Одноклассники», да, возьмем в пример, конечно. Нужно было, условно, сделать авторизацию с помощью «Одноклассников», и нужно было у конкретного пользователя, кто делает через этот сервис авторизацию, подтянуть его друзей. Собственно, эта опишка возвращала некоторый JSON-формат."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:13:19,480",
            "timestamp_end": "00:13:25,010",
            "text": "И вот эти настройки нужно было как раз у нас хранить именно в JSON."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:13:25,010",
            "timestamp_end": "00:13:26,430",
            "text": "вот в виде строки"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:13:26,430",
            "timestamp_end": "00:13:28,250",
            "text": "Это нужно было"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:13:28,250",
            "timestamp_end": "00:13:34,190",
            "text": "Ну, хранить их потом при получении, условно, происходит там диссерилизация, всё очень быстро"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:13:34,190",
            "timestamp_end": "00:13:42,460",
            "text": "маппиться к нужным свойствам и, собственно, могли дальше как-то эти данные обрабатывать. Вот. А когда нужно использовать таблички,"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:14:23,540",
            "timestamp_end": "00:14:34,880",
            "text": "в рамках одного запроса именно JSON-ом. Мы его получаем, и его можем на практике как-то использовать. Если мы говорим про обычную таблицу, то это уже нормализация как бы идет,"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:14:46,760",
            "timestamp_end": "00:15:07,030",
            "text": "Ну, вообще, здесь, если у тебя глубокая структура какая-то, да, то есть ты используешь JSON, потому что тебе придётся создавать, там, десяток табличек, то есть десяток табличек либо JSON, да, с которым ты будешь и так постоянно, там, что-то работать. Просто вычитывайте, пишите данные. Это не какие-то, там, поиски. Делайте какую-то сложную логику на делать. Ну, а ещё, если у тебя изменяющаяся структура данных,"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:15:07,030",
            "timestamp_end": "00:15:26,040",
            "text": "Это тоже вполне себе возможно, когда, например, пользователь настраивает, у него есть какой-то конструктор, грубо говоря, где он, там, определяет какие-то поля. Тебе с фронта приходит конкретный JSON-чик, да, там, с нужными парами, которые есть, и ты его тоже сохраняешь, потому что ты не знаешь, какая структура от пользователя тебе придёт."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:15:26,180",
            "timestamp_end": "00:15:38,320",
            "text": "Вот это тоже такой вариант. Ну и на самом деле, меньше весит, потому что Json, он, действительно, если ты вот эту структуру, там, разобьёшь на сколько-то табличек, то это всё, меньше весит."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:16:37,210",
            "timestamp_end": "00:16:39,800",
            "text": "По этому значению является что-то типа."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:16:52,040",
            "timestamp_end": "00:16:53,560",
            "text": "А строки приходилось лачить?"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:16:55,440",
            "timestamp_end": "00:16:58,940",
            "text": "Вроде бы за практику было, я вот такое вспоминаю."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:16:59,540",
            "timestamp_end": "00:17:11,460",
            "text": "Селект фор апдейт. Если это речь про это, это же, по сути, тоже… Селект фор апдейт, когда мы выполняем, это вроде бы лог на конкретную строку. То есть в рамках отдельного, допустим…"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:18:53,360",
            "timestamp_end": "00:18:57,060",
            "text": "За загрузки данных, не знаю, можно ли сказать, что это интересно было."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:18:57,240",
            "timestamp_end": "00:19:14,390",
            "text": "Я, так сказать, разбирался с лишними инклюдами, которые были. Был опыт написания inner join-а, вот тоже я помню task-у, потому что include — это обычно left join. Потом… А, конфигурационные файлы. У нас всё было в рамках метода onModelCreating. Я вносил практику"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:19:14,390",
            "timestamp_end": "00:19:19,140",
            "text": "Так сказать, распределение по конфигурационным файлам, чтобы всё было очень удобно."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:19:19,140",
            "timestamp_end": "00:19:21,080",
            "text": "Вот, что ещё?"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:19:21,440",
            "timestamp_end": "00:19:41,400",
            "text": "Про чиндж-трекер, ну, тут не скажу, что сильно сталкивался, просто про него слышал, там, S-Mode трекинг по мере необходимости использовал. Даппер был, даппер, вот, но с даппером, честно, ну, больше нравится F-Core, не знаю, как будто больше нравится именно с ним работать, копать, как он под капотом устроен, вот, но с даппером тоже был опыт."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:19:41,920",
            "timestamp_end": "00:19:43,700",
            "text": "Небольшой, но был."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:21:09,860",
            "timestamp_end": "00:21:17,060",
            "text": "Вот. Ещё ты говорил что-то про какие-то… Про загрузку данных."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:21:33,940",
            "timestamp_end": "00:21:42,420",
            "text": "Бывает полезно, когда нам сразу нужны данные, но когда мы их не используем, навигационные, это может только нам ухудшить по производительности, потому что время тратится."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:21:42,420",
            "timestamp_end": "00:21:50,140",
            "text": "На join. Вот. Это ленивое. Явное — с помощью обращения к контексту и вызова метод entry."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:21:50,140",
            "timestamp_end": "00:21:59,910",
            "text": "Ну, вызываем метод «Entry», прокидываем сущность и в зависимости от дальшей цепочки методов подгружаем либо один объект, либо коллекцию объектов. Вот."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:21:59,910",
            "timestamp_end": "00:22:14,330",
            "text": "Что у нас? «Ленивая»? «Ленивая» вроде бы с помощью прокси. Там библиотека отдельно ставится, как я помню. Прокси, как там, «Entity Framework Core», и там она построена на виртуальных свойств. Вся"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:22:39,060",
            "timestamp_end": "00:22:40,400",
            "text": "Так, сколько?"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:23:06,960",
            "timestamp_end": "00:23:10,220",
            "text": "А вот конкретно какая запись изменилась, она"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:23:10,220",
            "timestamp_end": "00:23:24,160",
            "text": "Выставляется ей определенный статус, там, «Modified», и она будет изменяться. Если вообще никаких изменений не было, то у нас вроде бы статус выставляется «Unchanged», то есть никак не изменено, и…"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:23:24,160",
            "timestamp_end": "00:23:27,350",
            "text": "Соответственно, сохранений никаких не будет происходить."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:23:27,350",
            "timestamp_end": "00:23:40,580",
            "text": "Статусов может быть несколько — «Modified», «Edit», «Deleted», вроде бы, или «Remove» называется. Вот. А этот Change Tracker, он не всегда бывает, так сказать, нужен при, допустим, Get-операциях, когда нам ничего не надо изменять."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:23:51,020",
            "timestamp_end": "00:23:53,040",
            "text": "но в объекте, как вы настраивали."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:25:23,740",
            "timestamp_end": "00:25:27,780",
            "text": "Это полезно, когда у тебя Декартова перемножение"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:25:28,520",
            "timestamp_end": "00:25:35,960",
            "text": "Из-за джойнов происходит, вот, взрыв данных. Распухает вот это решение, как вариант."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:25:36,720",
            "timestamp_end": "00:25:41,380",
            "text": "Через отдельные. То есть он три запроса просто делает. Ну, примерно, да."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:25:41,760",
            "timestamp_end": "00:25:43,740",
            "text": "А миграции как у вас?"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:26:04,340",
            "timestamp_end": "00:26:11,440",
            "text": "А, ну, ещё у нас был прикол через отдельные скейл-файлы. То есть, у нас и была папочка «Migrations», там"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:26:31,280",
            "timestamp_end": "00:26:35,880",
            "text": "А вот как вы их менеджили? То есть, как деплоили, например, приложение?"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:26:55,530",
            "timestamp_end": "00:27:01,290",
            "text": "Ну, накатывали, условно указывали схему, и к этой схеме БДшки делали просто..."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:27:01,290",
            "timestamp_end": "00:27:02,450",
            "text": "Релиз."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:28:13,240",
            "timestamp_end": "00:28:24,120",
            "text": "А ещё такой вопрос про внутренний пул подключений к базе. Вот, у РЭМ, например, RedBug SQL представляет свой внутренний пул, и вот"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:28:46,050",
            "timestamp_end": "00:29:04,820",
            "text": "С саму настройку я прямо в рамках работы не сталкивался, то есть у меня не было таких задач, но, как я помню, там были свойства Max Size Pool, вроде бы максимальное количество полов одновременных на коннекшены, и сам я с ним игрался чисто вот на практике, ну, в своём подпроекте смотрел работу внутреннюю."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:29:04,860",
            "timestamp_end": "00:29:08,080",
            "text": "За какие-то более внутренние тонкости"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:30:21,080",
            "timestamp_end": "00:30:28,020",
            "text": "То такие задачи у нас были очень часто из-за нагрузки. Но опять, там у нас решали их задачи уже сеньоры."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:30:28,020",
            "timestamp_end": "00:30:35,540",
            "text": "До меня прям как-то балансировщик не доходил. Я в курсе, что с помощью него можно распределять нагрузку, междуусловно."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:31:51,160",
            "timestamp_end": "00:32:02,410",
            "text": "Это прямо в продакшене у нас было. Пробовал свои примеры посмотреть, тоже, как он реализовывается на своей практике. Что, по сути, в рамках Рэббита у нас есть экчейндж, есть очередь."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:32:02,410",
            "timestamp_end": "00:32:21,660",
            "text": "Exchange связывается с очередью по routing.k. Если рассматривать, допустим, Kafka, то там схема работы немножко другая. Есть продюсер, есть, по сути, сама очередь. В рамках очереди есть топики, в рамках топиков могут быть партишены. И, по сути, из очереди сразу сообщение доставляется в продюсер."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:32:21,940",
            "timestamp_end": "00:32:41,960",
            "text": "Вот. Как-то так, по сути. Про Outbox транзакшн тоже слышал, что он очень часто встречается для гарантии доставки сообщений. Потом, про гарантию доставки сообщений — это «at most once», то есть хотя бы один раз, как максимум, как минимум один раз,. At least once. И ещё какой там?"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:33:21,430",
            "timestamp_end": "00:33:28,410",
            "text": "Этой гарантии, ну, при этом функционале у нас была гарантия как максимум один раз."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:33:28,410",
            "timestamp_end": "00:33:32,760",
            "text": "Во, то есть, ну, нам неважно было, потеряется сообщение в моменте или нет."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:33:33,220",
            "timestamp_end": "00:33:48,020",
            "text": "Когда это уже были какие-то сложные, допустим, ну, в рамках микросервисов операции, то там уже использовался подход как минимум один раз, потому что потерять какое-то сообщение было очень, ну, так сказать, трудно."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:34:10,460",
            "timestamp_end": "00:34:19,720",
            "text": "Да, в этой как раз проблеме как минимум один раз у нас может быть дубли. Там вообще, я смотрел, четыре ситуации могут быть. Ну вот, одна из них — это дубли. Допустим..."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:34:20,160",
            "timestamp_end": "00:34:24,770",
            "text": "Ну самый такой банальный механизм — это по какому-нибудь айдишнику"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:34:24,770",
            "timestamp_end": "00:34:27,440",
            "text": "в сообщении его прокидывать, и чтобы была"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:34:27,440",
            "timestamp_end": "00:34:47,830",
            "text": "Между ними разница. Там сообщение и конкретно идишник, допустим, пользователя уникальный. Вот. Либо если у нас event-сорсинг-архитектура по, допустим, ивенту. То есть, по ивенту уникальному мы могли в сообщение его прокидывать и его так идентифицировать, по сути, наше сообщение."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:34:47,830",
            "timestamp_end": "00:34:48,940",
            "text": "Я бы…"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:36:24,360",
            "timestamp_end": "00:36:40,500",
            "text": "Сообщение с обновлением, да, апдейтом каким-то. И вот тебе прилетело два разных сообщения с двумя разными апдейтами, там, одного и того же поля, например. Но они по пути в брокере, там, перепутались. И тебе первым пришло"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:37:01,320",
            "timestamp_end": "00:37:18,840",
            "text": "Сейчас надо подумать, как можно. Ну, мне почему-то на голову приходит, допустим, добавить какое-то свойство по времени, по дате создания, к примеру. Либо по дате обновления. Нет, по дате создания или обновления приходит в голову. Только надо подумать, как их проверять."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:37:20,640",
            "timestamp_end": "00:37:28,040",
            "text": "Ну, скорее всего, по времени. То есть, если у нас последнее обновление было, допустим,"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:37:29,200",
            "timestamp_end": "00:37:33,440",
            "text": "Блин, вопрос. Ещё раз, можно вопрос? Я вот… Есть два сообщения."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:40:09,710",
            "timestamp_end": "00:40:12,700",
            "text": "Неактуальное сообщение. Ну чтобы вот поддерживать"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:40:44,500",
            "timestamp_end": "00:40:49,440",
            "text": "Вот ты работаешь сейчас в финансовой организации, да?"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:42:26,900",
            "timestamp_end": "00:42:31,280",
            "text": "Порядок сообщений — это, конечно, хорошо."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:42:31,660",
            "timestamp_end": "00:42:41,510",
            "text": "В монолите он будет соблюдаться, но если ты работаешь с микросервисами, то ты не знаешь, какая реплика у тебя, какое сообщение. Вычитает первое, начнет его первое обрабатывать."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:42:41,510",
            "timestamp_end": "00:42:55,000",
            "text": "Одна реплика может вычитать сообщение, например, о списании, а другая — о пополнении, да. И реплика о списании начнёт работать чуть-чуть быстрее, потому что, я не знаю, у неё сервер чуть-чуть… ну, машинка чуть-чуть быстрее, а у той такая не будет."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:43:13,120",
            "timestamp_end": "00:43:14,740",
            "text": "Вот расскажи."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:43:36,650",
            "timestamp_end": "00:43:45,640",
            "text": "Ну, понятно, что они не все используются, но про них стараюсь читать, как только происходит, там, апдейт в сентябре, в ноябре. Вот, стараюсь читать."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:43:45,840",
            "timestamp_end": "00:43:59,440",
            "text": "К примеру, классные штуки, которые у нас очень зашли, это рекорды в.NET 5-ом появились. Потом я слышал, прикольная штука — дом, ну, дерево выражений появилось у нас в.NET-е."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:43:59,740",
            "timestamp_end": "00:44:19,560",
            "text": "Frozen Dictionary, я помню, у нас архитектор про это рассказывал. Как под капотом, честно, ну, не расскажу прям детально, но смотрел. Что ещё прикольного? Ну, там, сериализация, то есть, вот, System Tech JSON, сериализация, децерилизация улучшалась по времени."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:44:19,840",
            "timestamp_end": "00:44:30,400",
            "text": "А вот, кого смотрю прям тоже, ну, Анг… Джаванович, смотрю его, у него очень классный, вроде так правильно произв… его имя, классный"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:44:30,700",
            "timestamp_end": "00:44:33,940",
            "text": "Классный контент из русскоязычных"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:45:59,560",
            "timestamp_end": "00:46:08,100",
            "text": "Не все проекты мы на него переводили. Могу точно… Ну, могу спутать версию, «Дотент 5-й» или «Дотент 6-й», но какая-то версия была"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:46:31,500",
            "timestamp_end": "00:46:36,140",
            "text": "Батчами обновление, батчами удаление. Что давно просили?"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:48:00,770",
            "timestamp_end": "00:48:12,740",
            "text": "Ну да, сложная штука на самом деле. Там вот этот паттерн-визитор, и тебе приходится декларативно всё вот это просматривать, а как построить, там, какое-то предложение, там, ещё что-то из него создать."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:48:52,500",
            "timestamp_end": "00:49:06,470",
            "text": "Слушай, вот ты наверняка, там, на SpendCore писал часто какие-то интеграции, больше ничего не делал. Вот, там, в SpendCore есть такая школа, как Http Client Factory. Вот, может, знаешь, зачем её добавили, какие она проблемы решает?"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:49:24,880",
            "timestamp_end": "00:49:38,560",
            "text": "Занас под капотом занимается созданием и, там, условно, удалением, как фредпул, условно, вот этих http-клайентов. Это первая проблема. Вторая проблема, я слышал, связана с ДНС-ами, что"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:49:38,560",
            "timestamp_end": "00:49:51,970",
            "text": "Честно, сейчас прям детально не расскажу, потому что давно сталкивался, ну, читал про это, но знаю, что может быть проблема с ДНС-ами, когда у нас закончатся полы подключений, и может случиться такая проблема, что собьется ДНС."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:50:13,840",
            "timestamp_end": "00:50:16,920",
            "text": "Ну да, всё правильно. Окей."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:50:46,000",
            "timestamp_end": "00:50:47,740",
            "text": "Плюсы строк."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:50:48,920",
            "timestamp_end": "00:51:02,420",
            "text": "Ну, не знаю, можно ли назвать, что, допустим, если у нас есть одна строка с одинаковым названием, то она ссылается на один участок памяти. Насколько это применимо? Ну, вот, не знаю, могу предположить, что это плюс. Плюс строки."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:51:04,140",
            "timestamp_end": "00:51:14,520",
            "text": "Ну, я знаю, что строки — это ссылочный тип данных, но их поведение, оно как у значимого типа данных. То есть, если мы её передаём в метод, то у нас получается копирование строки."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:51:27,180",
            "timestamp_end": "00:51:32,240",
            "text": "По значению, но копирование строки мне будет, простите. Сейчас по ссылке оно передаётся."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:52:36,400",
            "timestamp_end": "00:52:49,620",
            "text": "Ну вот да, то есть. Да, да. Ну, как я смотрел, то у нас просто будет ссылание на одну ячейку в памяти. Может быть, это сделано с помощью интернирования строк? Под капотом как-то реализовано хитро."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:54:01,010",
            "timestamp_end": "00:54:06,210",
            "text": "Читал пост касаемо вот этих тоже, ну, всяких прикольных моментов со строками."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:54:06,210",
            "timestamp_end": "00:54:24,370",
            "text": "Я смотрел и помню, что если, допустим, у нас строка маленькая, и нужно сделать какие-то, ну, небольшие преобразования, то конкат в этом случае будет отрабатывать вроде бы быстрее, чем стрингбилдер, потому что стрингбилдер нам нужно, во-первых, инициализировать, под капотом он там выделяет сразу место,"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:54:24,370",
            "timestamp_end": "00:54:32,800",
            "text": "достаточно большое. И если у нас строки маленькие, ну то есть нужно с ними небольшие операции сделать, то конкатенация здесь, скорее всего,"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:54:32,800",
            "timestamp_end": "00:54:34,260",
            "text": "Будет маст… Ну."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:54:38,880",
            "timestamp_end": "00:54:45,300",
            "text": "А приходилось тебе вообще какие-нибудь утечки памяти, там, профайлить, анализировать, исправлять?"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:55:00,080",
            "timestamp_end": "00:55:08,270",
            "text": "А, там, Dictionary, и мутабельный… и мутабельного Dictionary. Ну, и мутабельный коллекция, точнее. И Frozen. Вот."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:55:08,270",
            "timestamp_end": "00:55:09,910",
            "text": "Памяти."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:58:20,640",
            "timestamp_end": "00:58:23,900",
            "text": "А, что ещё раз? — «Интерфейсом» — «I observable»."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "00:59:28,080",
            "timestamp_end": "00:59:39,080",
            "text": "1988 там другая там полностью ругая парадигма синхронного программирования хотя синхронность нам гораздо быстрее получается сливать за"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "01:00:19,960",
            "timestamp_end": "01:00:33,700",
            "text": "Монитор, что ещё у нас, семафор, они как бы идут напрямую в ядро операционной системы. А гибридные — это Slim-версии. Вот я как вспоминаю, там, семафор Slim, к примеру, что ещё у нас есть из Slim-версии."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "01:00:33,980",
            "timestamp_end": "01:00:44,480",
            "text": "ReaderWrite, LogSlim вроде бы, что ли. Они как бы крутятся в специальном отдельном спинвейте и нужны для оптимизации, когда очень быстро выполняются у нас"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "01:00:44,480",
            "timestamp_end": "01:00:53,670",
            "text": "Блокировки и вот эти моменты. Вот. На практике использовал Mutex. Обычный лог у нас тоже был. По сути, это монитор. Что ещё?"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "01:02:08,580",
            "timestamp_end": "01:02:15,740",
            "text": "что поделится на «Альгиона». Ну ладно, это тоже, это прям уже совсем глубоко, вот."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "01:02:32,000",
            "timestamp_end": "01:02:35,560",
            "text": "САД, вот эти вот всё. Да, с докера начнём."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "01:02:44,800",
            "timestamp_end": "01:03:02,140",
            "text": "Сред. Сперва у нас всё в ИСе вообще разворачивалось, но потом пришли к использованию докер, создавал докер-контейнеры, по сути, с докер-файлом работал. Не сказать, что прям все детальные команды условно знаю, в процессе разбираюсь. Ну и плюс, когда свои, там, пэт-проекты пишу,"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "01:05:48,860",
            "timestamp_end": "01:05:51,440",
            "text": "В OPCI-CD, получается,"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "01:05:51,680",
            "timestamp_end": "01:05:56,840",
            "text": "у вас это все настроено строена на было кем-то то есть до 2 в санте условно туда"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "01:06:17,520",
            "timestamp_end": "01:06:31,770",
            "text": "Там пайплайны выполняются. Можно к ним прикрутить разные правила. Там, допустим, в зависимости от названия ветки мы ставим разрешение, там, мердж или нет. А с Github'ом… У нас Github тоже использовался, но"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "01:09:36,460",
            "timestamp_end": "01:09:50,340",
            "text": "Да, во, то есть, у нас Графана была, с ней я поработал. Но в основном нам просто звонили, то есть, если что-то ночью падает, звонили, вот так. Ну это алерты как раз, я не знаю, можно ли это назвать. Уведомления у нас приходили тоже."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "01:09:50,340",
            "timestamp_end": "01:09:58,360",
            "text": "А вот вспомнил, когда что-то ломалось, приходили просто в слаке от бота. Но ночью, к примеру, фиг посмотришь, звонки просто тупо шли."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "01:09:59,520",
            "timestamp_end": "01:10:05,260",
            "text": "Ну да, понятно. Ну, собственно. А метрики, вот, какие-то вы отслеживали, вот, в приложении?"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "01:10:06,140",
            "timestamp_end": "01:10:20,480",
            "text": "Counter, я помню, точно использовался у нас. Метрики. Ну, у нас очень большая была метрика по нашим ивентам аналитическим, там, с какой скоростью, условно, выполняются запросы. Вот больше для этого"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "01:10:56,160",
            "timestamp_end": "01:10:57,320",
            "text": "А, да, у нас."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "01:11:01,620",
            "timestamp_end": "01:11:21,830",
            "text": "ПО для логов. В основном мы сперва, ну, мы сразу начали использовать неориентированную базу данных Clickhouse, потому что она как раз для сбора данных очень классная штука. Там под капотом движки, и в зависимости от движков, ну, там, в общем, движки на любой вкус, и как раз для логов они идеально подходили."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "01:11:21,830",
            "timestamp_end": "01:11:24,340",
            "text": "и просто в нашей собственной системе"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "01:12:28,240",
            "timestamp_end": "01:12:30,480",
            "text": "А, да, у нас… Да, да."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "01:12:30,480",
            "timestamp_end": "01:12:44,770",
            "text": "Я использовал интеграционный тест для микросервисов, а юнит-тесты на.NET и функциональные на Python. Правда, с функциональными было немножко. Вот. У нас на проекте вообще тестов, от слова, было совсем ноль, их просто не было."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "01:12:59,080",
            "timestamp_end": "01:13:10,940",
            "text": "Ну, приводили, так сказать, к серьезным проблемам. И я, собственно, предложил идею. У нас команда на этом проекте была из пяти человек, чтобы начать писать юнит-тесты. Вот. Я занялся написанием..."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "01:13:36,700",
            "timestamp_end": "01:13:39,460",
            "text": "Очень похоже, на самом деле, по своей…"
        },
        {
            "speaker": "interviewer",
            "timestamp_start": "01:13:39,460",
            "timestamp_end": "01:13:43,340",
            "text": "То есть, ну ладно, давай так, компонентные тесты"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "01:14:02,840",
            "timestamp_end": "01:14:08,630",
            "text": "А интеграционные в целом большой скоб каких-то компонентов под себя подразумевают и тестируют."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "01:14:26,690",
            "timestamp_end": "01:14:36,490",
            "text": "По сути, у тебя другое приложение тестирует свое приложение на какие-то… То есть оно уже непосредственно отбирает запросы, к нему реквесты, смотрит, какие ответы ему придут."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "01:14:36,490",
            "timestamp_end": "01:14:47,960",
            "text": "Там ещё всякая такая штука. То есть, это ещё такой, чуть более широкий. Там уже проверяется сама диссерилизация твоего запроса. То есть, запросы, как правило, приходят, там, в результате, ещё что-то. Ну, это так, по этим."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "01:14:47,960",
            "timestamp_end": "01:14:50,320",
            "text": "Так, хорошо."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "01:14:50,700",
            "timestamp_end": "01:14:56,980",
            "text": "Рахажи, вот как вы подымали базу данных для тестов? Вообще, как это происходило?"
        },
        {
            "speaker": "candidate",
            "timestamp_start": "01:15:21,760",
            "timestamp_end": "01:15:36,420",
            "text": "Большим объём данных, вот. У нас в основном использовался клик для этих ситуаций, чтобы по… Ну, из клихауса, как вот я на практике встречал, можно с помощью, как сказать, кавычек, доставать определённые данные там."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "01:17:28,700",
            "timestamp_end": "01:17:39,870",
            "text": "Вспоминаю, у нас использовалась такая либо как автофикстура, что ли. Автофикстура, да. Да, она как бы сразу нам и приводила нужный объём данных."
        },
        {
            "speaker": "candidate",
            "timestamp_start": "01:17:49,680",
            "timestamp_end": "01:17:51,260",
            "text": "Тут, наверное, это Москва."
        }
    ]
}